{"ast":null,"code":"export var findScrollParent = function findScrollParent(element, horizontal) {\n  var result;\n  if (element) {\n    var parent = element.parentNode;\n    while (!result && parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect();\n      // 10px is to account for borders and scrollbars in a lazy way\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result = parent;\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result = parent;\n      }\n      parent = parent.parentNode;\n    }\n    // last scrollable element will be the document\n    // if nothing else is scrollable in the page\n    if (!result) {\n      result = document;\n    } else if (result.tagName.toLowerCase() === 'body') {\n      result = document;\n    }\n  }\n  return result;\n};\nvar documentTags = ['html', 'body'];\nexport var findScrollParents = function findScrollParents(element, horizontal) {\n  var result = [];\n  if (element) {\n    var parent = element.parentNode;\n    while (parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect();\n      // 10px is to account for borders and scrollbars in a lazy way\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result.push(parent);\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result.push(parent);\n      }\n      parent = parent.parentNode;\n    }\n    if (result.length && documentTags.includes(result[0].tagName.toLowerCase())) {\n      result.length = 0;\n    }\n    // last scrollable element will be the document\n    result.push(document);\n  }\n  return result;\n};\nexport var containsFocus = function containsFocus(node) {\n  var root = node.getRootNode();\n  var element = root.activeElement;\n  while (element) {\n    if (element === node) break;\n    element = element.parentElement;\n  }\n  return !!element;\n};\nexport var withinDropPortal = function withinDropPortal(node, portalContext) {\n  var root = node == null ? void 0 : node.getRootNode();\n  var element = node;\n  var portalId;\n  while (element && element !== root) {\n    if (element.hasAttribute('data-g-portal-id')) {\n      portalId = element.getAttribute('data-g-portal-id');\n      element = root;\n    } else {\n      element = element.parentElement;\n    }\n  }\n  // if portalContext doesn't contain the portalId then the\n  // portal is new and node is within a drop that just opened\n  if (portalId === undefined || portalContext.indexOf(parseInt(portalId, 10)) !== -1) return false;\n  return true;\n};\n\n// Check if the element.tagName is an input, select or textarea\nexport var isFocusable = function isFocusable(element) {\n  var tagName = element.tagName.toLowerCase();\n  return tagName === 'input' || tagName === 'select' || tagName === 'textarea';\n};\n\n// Get the first element that can receive focus\nexport var getFirstFocusableDescendant = function getFirstFocusableDescendant(element) {\n  var children = element.getElementsByTagName('*');\n  for (var i = 0; i < children.length; i += 1) {\n    var child = children[i];\n    if (isFocusable(child)) {\n      return child;\n    }\n  }\n  return undefined;\n};\nexport var shouldKeepFocus = function shouldKeepFocus(root) {\n  var element = root.activeElement;\n  if (isFocusable(element)) return true;\n  return !!getFirstFocusableDescendant(element);\n};\nexport var getNewContainer = function getNewContainer(target, targetChildPosition) {\n  if (target === void 0) {\n    target = document.body;\n  }\n  // setup DOM\n  var container = document.createElement('div');\n  if (targetChildPosition === 'first') {\n    // for SkipLinks\n    target.prepend(container);\n  } else {\n    target.appendChild(container);\n  }\n  return container;\n};\nexport var setFocusWithoutScroll = function setFocusWithoutScroll(element) {\n  var x = window.scrollX;\n  var y = window.scrollY;\n  element.focus();\n  window.scrollTo(x, y);\n};\nvar TABINDEX = 'tabindex';\nvar TABINDEX_STATE = 'data-g-tabindex';\nexport var makeNodeFocusable = function makeNodeFocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.removeAttribute('aria-hidden');\n    // allow children to receive focus again\n    var elements = node.getElementsByTagName('*');\n    // only reset elements we've changed in makeNodeUnfocusable()\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.hasAttribute(TABINDEX_STATE);\n    }).forEach(function (element) {\n      var prior = element.getAttribute(TABINDEX_STATE);\n      if (prior >= 0) {\n        element.setAttribute(TABINDEX, element.getAttribute(TABINDEX_STATE));\n      } else if (prior === 'none') {\n        element.removeAttribute(TABINDEX);\n      }\n      element.removeAttribute(TABINDEX_STATE);\n    });\n  }\n};\n\n// Using ^ and $ to match the whole tagName, and not e.g. <meta> and <data>.\nvar autoFocusingTags = /^(a|area|input|select|textarea|button|iframe)$/;\nexport var makeNodeUnfocusable = function makeNodeUnfocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.setAttribute('aria-hidden', true);\n    // prevent children to receive focus\n    var elements = node.getElementsByTagName('*');\n    // first, save off the tabIndex of any element with one\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.getAttribute(TABINDEX) !== null;\n    }).forEach(function (element) {\n      // if TABINDEX_STATE already exists, it's holding the original value\n      if (!element.getAttribute(TABINDEX_STATE)) element.setAttribute(TABINDEX_STATE, element.getAttribute(TABINDEX));\n      element.setAttribute(TABINDEX, -1);\n    });\n    // then, if any element is inherently focusable and not handled above,\n    // give it a tabIndex of -1 so it can't receive focus\n    Array.prototype.filter.call(elements || [], function (element) {\n      var currentTag = element.tagName.toLowerCase();\n      return currentTag.match(autoFocusingTags) && element.focus && element.getAttribute(TABINDEX_STATE) === null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, 'none');\n      element.setAttribute(TABINDEX, -1);\n    });\n  }\n};\nvar _findVisibleParent = function findVisibleParent(element) {\n  if (element) {\n    // Get the closest ancestor element that is positioned.\n    return element.offsetParent ? element : _findVisibleParent(element.parentElement) || element;\n  }\n  return undefined;\n};\nexport { _findVisibleParent as findVisibleParent };\nexport var isNodeAfterScroll = function isNodeAfterScroll(node, target) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    bottom = _node$getBoundingClie.bottom;\n  // target will be the document from findScrollParent()\n  var _ref = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n      height: 0,\n      top: 0\n    },\n    height = _ref.height,\n    top = _ref.top;\n  return bottom >= top + height;\n};\nexport var isNodeBeforeScroll = function isNodeBeforeScroll(node, target) {\n  var _node$getBoundingClie2 = node.getBoundingClientRect(),\n    top = _node$getBoundingClie2.top;\n  // target will be the document from findScrollParent()\n  var _ref2 = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n      top: 0\n    },\n    targetTop = _ref2.top;\n  return top <= targetTop;\n};\nvar _findButtonParent = function findButtonParent(element) {\n  if (element && element.nodeName !== 'BUTTON' && element.nodeName !== 'A') return _findButtonParent(element.parentElement);\n  return element;\n};\nexport { _findButtonParent as findButtonParent };","map":{"version":3,"names":["findScrollParent","element","horizontal","result","parent","parentNode","getBoundingClientRect","rect","width","scrollWidth","height","scrollHeight","document","tagName","toLowerCase","documentTags","findScrollParents","push","length","includes","containsFocus","node","root","getRootNode","activeElement","parentElement","withinDropPortal","portalContext","portalId","hasAttribute","getAttribute","undefined","indexOf","parseInt","isFocusable","getFirstFocusableDescendant","children","getElementsByTagName","i","child","shouldKeepFocus","getNewContainer","target","targetChildPosition","body","container","createElement","prepend","appendChild","setFocusWithoutScroll","x","window","scrollX","y","scrollY","focus","scrollTo","TABINDEX","TABINDEX_STATE","makeNodeFocusable","removeAttribute","elements","Array","prototype","filter","call","forEach","prior","setAttribute","autoFocusingTags","makeNodeUnfocusable","currentTag","match","_findVisibleParent","findVisibleParent","offsetParent","isNodeAfterScroll","_node$getBoundingClie","bottom","_ref","top","isNodeBeforeScroll","_node$getBoundingClie2","_ref2","targetTop","_findButtonParent","findButtonParent","nodeName"],"sources":["C:/Users/michaejo/Documents/GitRepos/player-api/node_modules/grommet/es6/utils/DOM.js"],"sourcesContent":["export var findScrollParent = function findScrollParent(element, horizontal) {\n  var result;\n  if (element) {\n    var parent = element.parentNode;\n    while (!result && parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect();\n      // 10px is to account for borders and scrollbars in a lazy way\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result = parent;\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result = parent;\n      }\n      parent = parent.parentNode;\n    }\n    // last scrollable element will be the document\n    // if nothing else is scrollable in the page\n    if (!result) {\n      result = document;\n    } else if (result.tagName.toLowerCase() === 'body') {\n      result = document;\n    }\n  }\n  return result;\n};\nvar documentTags = ['html', 'body'];\nexport var findScrollParents = function findScrollParents(element, horizontal) {\n  var result = [];\n  if (element) {\n    var parent = element.parentNode;\n    while (parent && parent.getBoundingClientRect) {\n      var rect = parent.getBoundingClientRect();\n      // 10px is to account for borders and scrollbars in a lazy way\n      if (horizontal) {\n        if (rect.width && parent.scrollWidth > rect.width + 10) {\n          result.push(parent);\n        }\n      } else if (rect.height && parent.scrollHeight > rect.height + 10) {\n        result.push(parent);\n      }\n      parent = parent.parentNode;\n    }\n    if (result.length && documentTags.includes(result[0].tagName.toLowerCase())) {\n      result.length = 0;\n    }\n    // last scrollable element will be the document\n    result.push(document);\n  }\n  return result;\n};\nexport var containsFocus = function containsFocus(node) {\n  var root = node.getRootNode();\n  var element = root.activeElement;\n  while (element) {\n    if (element === node) break;\n    element = element.parentElement;\n  }\n  return !!element;\n};\nexport var withinDropPortal = function withinDropPortal(node, portalContext) {\n  var root = node == null ? void 0 : node.getRootNode();\n  var element = node;\n  var portalId;\n  while (element && element !== root) {\n    if (element.hasAttribute('data-g-portal-id')) {\n      portalId = element.getAttribute('data-g-portal-id');\n      element = root;\n    } else {\n      element = element.parentElement;\n    }\n  }\n  // if portalContext doesn't contain the portalId then the\n  // portal is new and node is within a drop that just opened\n  if (portalId === undefined || portalContext.indexOf(parseInt(portalId, 10)) !== -1) return false;\n  return true;\n};\n\n// Check if the element.tagName is an input, select or textarea\nexport var isFocusable = function isFocusable(element) {\n  var tagName = element.tagName.toLowerCase();\n  return tagName === 'input' || tagName === 'select' || tagName === 'textarea';\n};\n\n// Get the first element that can receive focus\nexport var getFirstFocusableDescendant = function getFirstFocusableDescendant(element) {\n  var children = element.getElementsByTagName('*');\n  for (var i = 0; i < children.length; i += 1) {\n    var child = children[i];\n    if (isFocusable(child)) {\n      return child;\n    }\n  }\n  return undefined;\n};\nexport var shouldKeepFocus = function shouldKeepFocus(root) {\n  var element = root.activeElement;\n  if (isFocusable(element)) return true;\n  return !!getFirstFocusableDescendant(element);\n};\nexport var getNewContainer = function getNewContainer(target, targetChildPosition) {\n  if (target === void 0) {\n    target = document.body;\n  }\n  // setup DOM\n  var container = document.createElement('div');\n  if (targetChildPosition === 'first') {\n    // for SkipLinks\n    target.prepend(container);\n  } else {\n    target.appendChild(container);\n  }\n  return container;\n};\nexport var setFocusWithoutScroll = function setFocusWithoutScroll(element) {\n  var x = window.scrollX;\n  var y = window.scrollY;\n  element.focus();\n  window.scrollTo(x, y);\n};\nvar TABINDEX = 'tabindex';\nvar TABINDEX_STATE = 'data-g-tabindex';\nexport var makeNodeFocusable = function makeNodeFocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.removeAttribute('aria-hidden');\n    // allow children to receive focus again\n    var elements = node.getElementsByTagName('*');\n    // only reset elements we've changed in makeNodeUnfocusable()\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.hasAttribute(TABINDEX_STATE);\n    }).forEach(function (element) {\n      var prior = element.getAttribute(TABINDEX_STATE);\n      if (prior >= 0) {\n        element.setAttribute(TABINDEX, element.getAttribute(TABINDEX_STATE));\n      } else if (prior === 'none') {\n        element.removeAttribute(TABINDEX);\n      }\n      element.removeAttribute(TABINDEX_STATE);\n    });\n  }\n};\n\n// Using ^ and $ to match the whole tagName, and not e.g. <meta> and <data>.\nvar autoFocusingTags = /^(a|area|input|select|textarea|button|iframe)$/;\nexport var makeNodeUnfocusable = function makeNodeUnfocusable(node) {\n  // do not touch aria live containers so that announcements work\n  if (!node.hasAttribute('aria-live')) {\n    node.setAttribute('aria-hidden', true);\n    // prevent children to receive focus\n    var elements = node.getElementsByTagName('*');\n    // first, save off the tabIndex of any element with one\n    Array.prototype.filter.call(elements || [], function (element) {\n      return element.getAttribute(TABINDEX) !== null;\n    }).forEach(function (element) {\n      // if TABINDEX_STATE already exists, it's holding the original value\n      if (!element.getAttribute(TABINDEX_STATE)) element.setAttribute(TABINDEX_STATE, element.getAttribute(TABINDEX));\n      element.setAttribute(TABINDEX, -1);\n    });\n    // then, if any element is inherently focusable and not handled above,\n    // give it a tabIndex of -1 so it can't receive focus\n    Array.prototype.filter.call(elements || [], function (element) {\n      var currentTag = element.tagName.toLowerCase();\n      return currentTag.match(autoFocusingTags) && element.focus && element.getAttribute(TABINDEX_STATE) === null;\n    }).forEach(function (element) {\n      element.setAttribute(TABINDEX_STATE, 'none');\n      element.setAttribute(TABINDEX, -1);\n    });\n  }\n};\nvar _findVisibleParent = function findVisibleParent(element) {\n  if (element) {\n    // Get the closest ancestor element that is positioned.\n    return element.offsetParent ? element : _findVisibleParent(element.parentElement) || element;\n  }\n  return undefined;\n};\nexport { _findVisibleParent as findVisibleParent };\nexport var isNodeAfterScroll = function isNodeAfterScroll(node, target) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    bottom = _node$getBoundingClie.bottom;\n  // target will be the document from findScrollParent()\n  var _ref = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n      height: 0,\n      top: 0\n    },\n    height = _ref.height,\n    top = _ref.top;\n  return bottom >= top + height;\n};\nexport var isNodeBeforeScroll = function isNodeBeforeScroll(node, target) {\n  var _node$getBoundingClie2 = node.getBoundingClientRect(),\n    top = _node$getBoundingClie2.top;\n  // target will be the document from findScrollParent()\n  var _ref2 = target.getBoundingClientRect ? target.getBoundingClientRect() : {\n      top: 0\n    },\n    targetTop = _ref2.top;\n  return top <= targetTop;\n};\nvar _findButtonParent = function findButtonParent(element) {\n  if (element && element.nodeName !== 'BUTTON' && element.nodeName !== 'A') return _findButtonParent(element.parentElement);\n  return element;\n};\nexport { _findButtonParent as findButtonParent };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}