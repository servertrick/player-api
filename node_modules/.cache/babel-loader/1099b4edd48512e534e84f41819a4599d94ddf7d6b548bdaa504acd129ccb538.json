{"ast":null,"code":"export var normalizeValues = function normalizeValues(values) {\n  return (values || []).map(function (value, index) {\n    if (value === undefined) return {\n      value: [index, undefined]\n    };\n    if (Array.isArray(value)) return {\n      value: value\n    };\n    if (typeof value === 'object') return value;\n    return {\n      value: [index, value]\n    };\n  });\n};\nexport var calcMinMax = function calcMinMax(values, direction) {\n  var _ref, _ref2, _ref3, _ref4;\n  if (values === void 0) {\n    values = [];\n  }\n  // We default to 0 minimum as that's typically what's wanted.\n  // If callers want a narrower band, they can pass bounds explicitly.\n  var min0 = (_ref = direction && 0) != null ? _ref : undefined;\n  var max0 = (_ref2 = direction && 1) != null ? _ref2 : undefined;\n  var min1 = (_ref3 = direction && 0) != null ? _ref3 : undefined;\n  var max1 = (_ref4 = direction && 1) != null ? _ref4 : undefined;\n  values.forEach(function (value) {\n    var _value$value = value.value,\n      val0 = _value$value[0],\n      val1 = _value$value[1],\n      val2 = _value$value[2];\n    if (val0 !== undefined) {\n      min0 = min0 === undefined ? val0 : Math.min(min0, val0);\n      max0 = max0 === undefined ? val0 : Math.max(max0, val0);\n    }\n    if (val1 !== undefined) {\n      min1 = min1 === undefined ? val1 : Math.min(min1, val1);\n      max1 = max1 === undefined ? val1 : Math.max(max1, val1);\n    }\n    if (val2 !== undefined) {\n      min1 = min1 === undefined ? val2 : Math.min(min1, val2);\n      max1 = max1 === undefined ? val2 : Math.max(max1, val2);\n    }\n  });\n\n  // when max === min, offset them so we can show something\n  if (max0 === min0) {\n    if (max0 > 0) min0 = max0 - 1;else max0 = min0 + 1;\n  }\n  if (max1 === min1) {\n    if (max1 > 0) min1 = max1 - 1;else max1 = min1 + 1;\n  }\n  return direction === 'horizontal' ? {\n    x: {\n      min: min1,\n      max: max1\n    },\n    y: {\n      min: min0,\n      max: max0\n    }\n  } : {\n    x: {\n      min: min0,\n      max: max0\n    },\n    y: {\n      min: min1,\n      max: max1\n    }\n  };\n};\nexport var normalizeBounds = function normalizeBounds(boundsProp, values, direction) {\n  var result;\n  if (Array.isArray(boundsProp)) result = {\n    x: {\n      min: boundsProp[0][0],\n      max: boundsProp[0][1]\n    },\n    y: {\n      min: boundsProp[1][0],\n      max: boundsProp[1][1]\n    }\n  };else if (typeof boundsProp === 'object') result = boundsProp;else result = calcMinMax(values, direction);\n  return result;\n};\nexport var areNormalizedValuesEquals = function areNormalizedValuesEquals(valuesX, valuesY) {\n  console.warn(\"This function will be removed in the upcoming releases.\\nPlease get in touch with us if you have concerns.\");\n  if (!valuesX || !valuesY) return false;\n  if (valuesX.length !== valuesY.length) return false;\n  if (valuesX.length === 0) return true;\n  if (!valuesX[0].value || !valuesY[0].value) return false;\n  return valuesX.every(function (_, i) {\n    return valuesX[i].value.every(function (value, index) {\n      return value === valuesY[i].value[index];\n    });\n  });\n};\nexport var areNormalizedBoundsEquals = function areNormalizedBoundsEquals(boundsX, boundsY) {\n  console.warn(\"This function will be removed in the upcoming releases.\\nPlease get in touch with us if you have concerns.\");\n  if (!boundsX || !boundsY) return false;\n  if (boundsX.length !== boundsY.length || !(boundsX.length > 0)) return false;\n  return boundsX.every(function (_, i) {\n    return boundsX[i].every(function (value, index) {\n      return value === boundsY[i][index];\n    });\n  });\n};","map":{"version":3,"names":["normalizeValues","values","map","value","index","undefined","Array","isArray","calcMinMax","direction","_ref","_ref2","_ref3","_ref4","min0","max0","min1","max1","forEach","_value$value","val0","val1","val2","Math","min","max","x","y","normalizeBounds","boundsProp","result","areNormalizedValuesEquals","valuesX","valuesY","console","warn","length","every","_","i","areNormalizedBoundsEquals","boundsX","boundsY"],"sources":["C:/Users/michaejo/Documents/GitRepos/player-api/node_modules/grommet/es6/components/Chart/utils.js"],"sourcesContent":["export var normalizeValues = function normalizeValues(values) {\n  return (values || []).map(function (value, index) {\n    if (value === undefined) return {\n      value: [index, undefined]\n    };\n    if (Array.isArray(value)) return {\n      value: value\n    };\n    if (typeof value === 'object') return value;\n    return {\n      value: [index, value]\n    };\n  });\n};\nexport var calcMinMax = function calcMinMax(values, direction) {\n  var _ref, _ref2, _ref3, _ref4;\n  if (values === void 0) {\n    values = [];\n  }\n  // We default to 0 minimum as that's typically what's wanted.\n  // If callers want a narrower band, they can pass bounds explicitly.\n  var min0 = (_ref = direction && 0) != null ? _ref : undefined;\n  var max0 = (_ref2 = direction && 1) != null ? _ref2 : undefined;\n  var min1 = (_ref3 = direction && 0) != null ? _ref3 : undefined;\n  var max1 = (_ref4 = direction && 1) != null ? _ref4 : undefined;\n  values.forEach(function (value) {\n    var _value$value = value.value,\n      val0 = _value$value[0],\n      val1 = _value$value[1],\n      val2 = _value$value[2];\n    if (val0 !== undefined) {\n      min0 = min0 === undefined ? val0 : Math.min(min0, val0);\n      max0 = max0 === undefined ? val0 : Math.max(max0, val0);\n    }\n    if (val1 !== undefined) {\n      min1 = min1 === undefined ? val1 : Math.min(min1, val1);\n      max1 = max1 === undefined ? val1 : Math.max(max1, val1);\n    }\n    if (val2 !== undefined) {\n      min1 = min1 === undefined ? val2 : Math.min(min1, val2);\n      max1 = max1 === undefined ? val2 : Math.max(max1, val2);\n    }\n  });\n\n  // when max === min, offset them so we can show something\n  if (max0 === min0) {\n    if (max0 > 0) min0 = max0 - 1;else max0 = min0 + 1;\n  }\n  if (max1 === min1) {\n    if (max1 > 0) min1 = max1 - 1;else max1 = min1 + 1;\n  }\n  return direction === 'horizontal' ? {\n    x: {\n      min: min1,\n      max: max1\n    },\n    y: {\n      min: min0,\n      max: max0\n    }\n  } : {\n    x: {\n      min: min0,\n      max: max0\n    },\n    y: {\n      min: min1,\n      max: max1\n    }\n  };\n};\nexport var normalizeBounds = function normalizeBounds(boundsProp, values, direction) {\n  var result;\n  if (Array.isArray(boundsProp)) result = {\n    x: {\n      min: boundsProp[0][0],\n      max: boundsProp[0][1]\n    },\n    y: {\n      min: boundsProp[1][0],\n      max: boundsProp[1][1]\n    }\n  };else if (typeof boundsProp === 'object') result = boundsProp;else result = calcMinMax(values, direction);\n  return result;\n};\nexport var areNormalizedValuesEquals = function areNormalizedValuesEquals(valuesX, valuesY) {\n  console.warn(\"This function will be removed in the upcoming releases.\\nPlease get in touch with us if you have concerns.\");\n  if (!valuesX || !valuesY) return false;\n  if (valuesX.length !== valuesY.length) return false;\n  if (valuesX.length === 0) return true;\n  if (!valuesX[0].value || !valuesY[0].value) return false;\n  return valuesX.every(function (_, i) {\n    return valuesX[i].value.every(function (value, index) {\n      return value === valuesY[i].value[index];\n    });\n  });\n};\nexport var areNormalizedBoundsEquals = function areNormalizedBoundsEquals(boundsX, boundsY) {\n  console.warn(\"This function will be removed in the upcoming releases.\\nPlease get in touch with us if you have concerns.\");\n  if (!boundsX || !boundsY) return false;\n  if (boundsX.length !== boundsY.length || !(boundsX.length > 0)) return false;\n  return boundsX.every(function (_, i) {\n    return boundsX[i].every(function (value, index) {\n      return value === boundsY[i][index];\n    });\n  });\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}