{"ast":null,"code":"function _readOnlyError(r) {\n  throw new TypeError('\"' + r + '\" is read-only');\n}\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\nimport { InfiniteScrollPropTypes } from './propTypes';\nvar calculateLastPageBound = function calculateLastPageBound(show, step) {\n  return show ? Math.floor((show + step) / step) - 1 : 0;\n};\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n    _ref$items = _ref.items,\n    items = _ref$items === void 0 ? [] : _ref$items,\n    onMore = _ref.onMore,\n    renderMarker = _ref.renderMarker,\n    replace = _ref.replace,\n    show = _ref.show,\n    _ref$step = _ref.step,\n    step = _ref$step === void 0 ? 50 : _ref$step;\n  // item index to be made visible initially\n  var _useState = useState(),\n    scrollShow = _useState[0],\n    setScrollShow = _useState[1];\n\n  // the last page we have items for\n  var lastPage = useMemo(function () {\n    return Math.max(0, Math.ceil(items.length / step) - 1);\n  }, [items.length, step]);\n\n  // the pages we are rendering\n  var _useState2 = useState([0, calculateLastPageBound(show, step)]),\n    renderPageBounds = _useState2[0],\n    setRenderPageBounds = _useState2[1];\n\n  // the heights of the pages, approximated after we render the first page\n  // and then updated for pages that have rendered\n  var _useState3 = useState([]),\n    pageHeights = _useState3[0],\n    setPageHeights = _useState3[1];\n\n  // what we're waiting for onMore to give us\n  var _useState4 = useState(0),\n    pendingLength = _useState4[0],\n    setPendingLength = _useState4[1];\n  var aboveMarkerRef = useRef(); // only when replacing\n  var belowMarkerRef = useRef();\n\n  // scroll and resize handling\n  useEffect(function () {\n    var scrollParents;\n    var evaluate = function evaluate() {\n      if (!scrollParents) return;\n      var scrollParent = scrollParents[0];\n\n      // Determine the scroll position of the scroll container\n      var top;\n      var height;\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n      }\n      var offset = height / 4; // so we pre-load when the user scrolls slowly\n\n      // Use the pageHeights to determine what pages we should render based\n      // on the current scroll window.\n      var nextBeginPage = 0;\n      var index = 0;\n      var pagesHeight = pageHeights[index] || 0;\n      while (pageHeights[index + 1] && pagesHeight < top - offset) {\n        index += 1;\n        nextBeginPage += 1;\n        pagesHeight += pageHeights[index];\n      }\n      var nextEndPage = nextBeginPage;\n      while (pageHeights[index] !== undefined && pagesHeight < top + height + offset) {\n        index += 1;\n        nextEndPage += 1;\n        // when we haven't rendered the nextEndPage and we aren't replacing,\n        // we might not have a height for it yet\n        pagesHeight += pageHeights[index] || 0;\n      }\n      if (!replace) {\n        // when not replacing, never shrink bounds\n        nextBeginPage = 0;\n        nextEndPage = Math.max(renderPageBounds[1], nextEndPage);\n      }\n      if (show) {\n        // ensure we try to render any show page\n        var showPage = calculateLastPageBound(show, step);\n        nextBeginPage = Math.min(showPage, nextBeginPage);\n        nextEndPage = Math.max(showPage, nextEndPage);\n      }\n      if (nextBeginPage !== renderPageBounds[0] || nextEndPage !== renderPageBounds[1]) {\n        setRenderPageBounds([nextBeginPage, nextEndPage]);\n      }\n    };\n    var timer;\n    var debounce = function debounce() {\n      clearTimeout(timer);\n      timer = setTimeout(evaluate, 10);\n    };\n\n    // might not be there yet or might have already rendered everything\n    if (belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (sp) {\n        return sp.addEventListener('scroll', debounce);\n      });\n    }\n    window.addEventListener('resize', debounce);\n    evaluate();\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (sp) {\n          return sp.removeEventListener('scroll', debounce);\n        });\n      }\n      window.removeEventListener('resize', debounce);\n      clearTimeout(timer);\n    };\n  }, [pageHeights, renderPageBounds, replace, show, step]);\n\n  // check if we need to ask for more\n  useEffect(function () {\n    if (onMore && renderPageBounds[1] === lastPage && items.length >= pendingLength && items.length > 0) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [items.length, lastPage, onMore, pendingLength, renderPageBounds, step]);\n  useEffect(function () {\n    if (items.length === 0 && lastPage === 0 && pendingLength !== 0) {\n      setPageHeights([]);\n      setPendingLength(0);\n      setRenderPageBounds([0, calculateLastPageBound(show, step)]);\n    }\n  }, [lastPage, pendingLength, show, step, items.length]);\n\n  // scroll to any 'show'\n  useLayoutEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && belowMarkerRef.current && show !== scrollShow) {\n        // calculate show index based on beginPage\n        var showIndex = show - renderPageBounds[0] * step + (renderPageBounds[0] ? 1 : 0);\n        var showNode = belowMarkerRef.current.parentNode.children.item(showIndex);\n        if (showNode) {\n          var scrollParent = findScrollParent(showNode);\n          if (isNodeBeforeScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(true);\n          } else if (isNodeAfterScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(false);\n          }\n          // clean up after having shown\n          setScrollShow(show);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n    // Omitting scrollShow as a dependency due to concern that setScrollShow\n    // is being called within the timer. If left included, re-renders and other\n    // dependency values could change in an unpredictable manner during timer\n    // and potentially result in an infinite loop.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderPageBounds, show, step]);\n\n  // calculate and keep track of page heights\n  useLayoutEffect(function () {\n    // if don't have a belowMarker, we must have rendered everything already\n    if (!belowMarkerRef.current) return;\n\n    // calculate page heights for rendered pages\n    var rendered = belowMarkerRef.current.parentNode.children;\n    // ensure we've rendered the state we have\n    // above? + items in rendered pages + below === rendered DOM elements length\n    if ((aboveMarkerRef.current ? 1 : 0) + (renderPageBounds[1] - renderPageBounds[0] + 1) * step + 1 === rendered.length) {\n      var nextPageHeights;\n\n      // step through each page\n      var i = renderPageBounds[0];\n      var lastBottom;\n      while (i <= renderPageBounds[1]) {\n        var topIndex = (aboveMarkerRef.current ? 1 : 0) + (i - renderPageBounds[0]) * step;\n        var bottomIndex = Math.min(topIndex + step - 1, rendered.length - 1);\n        // we use lastBottom for top to ensure grid layouts work\n        var top = lastBottom !== undefined ? lastBottom : rendered.item(topIndex).getBoundingClientRect().top;\n        var _rendered$item$getBou = rendered.item(bottomIndex).getBoundingClientRect(),\n          bottom = _rendered$item$getBou.bottom;\n        var height = bottom - top;\n        if (bottom && (!pageHeights || pageHeights[i] !== height)) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          nextPageHeights[i] = height;\n        }\n        lastBottom = bottom;\n        i += 1;\n      }\n\n      // estimate page heights for pages we haven't rendered yet\n      while (replace && i <= lastPage) {\n        if (!pageHeights[i] && pageHeights[i] !== pageHeights[0]) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          // set to first page height\n          var _nextPageHeights = nextPageHeights;\n          nextPageHeights[i] = _nextPageHeights[0];\n        }\n        i += 1;\n      }\n      if (nextPageHeights) setPageHeights(nextPageHeights);\n    }\n  }, [lastPage, pageHeights, renderPageBounds, replace, step]);\n\n  // calculate the height above the first rendered page using the pageHeights\n  var aboveHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = 0;\n    while (i < renderPageBounds[0]) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n    return height;\n  }, [pageHeights, renderPageBounds, replace]);\n\n  // calculate the height below the last rendered page using the pageHeights\n  var belowHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = renderPageBounds[1] + 1;\n    while (i <= lastPage) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n    return height;\n  }, [lastPage, pageHeights, renderPageBounds, replace]);\n  var firstIndex = renderPageBounds[0] * step;\n  var lastIndex = Math.min((renderPageBounds[1] + 1) * step, items.length) - 1;\n  var result = [];\n  if (aboveHeight) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      ref: aboveMarkerRef,\n      flex: false,\n      height: aboveHeight + \"px\"\n    });\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n    result.push(marker);\n  }\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var child = children(item, itemsIndex);\n    result.push(child);\n  });\n  if (replace || renderPageBounds[1] < lastPage || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: !renderMarker && belowMarkerRef || undefined,\n      flex: false,\n      height: (belowHeight || 0) + \"px\"\n    });\n    if (renderMarker) {\n      // need to give it a key\n      var renderedMarker = renderMarker(_marker);\n      _marker = /*#__PURE__*/React.cloneElement(renderedMarker, {\n        key: 'below',\n        // We need to make sure our belowMarkerRef is tied to a component\n        // that has the same parent as the items being rendered. This is so\n        // we can use belowMarkerRef.current.parentNode.children to\n        // get a reference to the items in the DOM for calculating pageHeights.\n        //\n        // Since the caller might have included a ref in what their\n        // renderMarker returns, we have to take care of both refs.\n        // https://github.com/facebook/react/issues/8873#issuecomment-489579878\n        ref: function ref(node) {\n          // Keep your own reference\n          belowMarkerRef.current = node;\n          // Call the original ref, if any\n          var ref = renderedMarker.ref;\n          if (typeof ref === 'function') {\n            ref(node);\n          } else if (ref !== null) {\n            ref.current = node;\n          }\n        }\n      });\n    }\n    result.push(_marker);\n  }\n  return result;\n};\nInfiniteScroll.propTypes = InfiniteScrollPropTypes;\nexport { InfiniteScroll };","map":{"version":3,"names":["_readOnlyError","r","TypeError","React","useEffect","useMemo","useRef","useState","useLayoutEffect","findScrollParent","findScrollParents","isNodeAfterScroll","isNodeBeforeScroll","Box","InfiniteScrollPropTypes","calculateLastPageBound","show","step","Math","floor","InfiniteScroll","_ref","children","_ref$items","items","onMore","renderMarker","replace","_ref$step","_useState","scrollShow","setScrollShow","lastPage","max","ceil","length","_useState2","renderPageBounds","setRenderPageBounds","_useState3","pageHeights","setPageHeights","_useState4","pendingLength","setPendingLength","aboveMarkerRef","belowMarkerRef","scrollParents","evaluate","scrollParent","top","height","document","documentElement","scrollTop","body","window","innerHeight","rect","getBoundingClientRect","offset","nextBeginPage","index","pagesHeight","nextEndPage","undefined","showPage","min","timer","debounce","clearTimeout","setTimeout","current","forEach","sp","addEventListener","removeEventListener","showIndex","showNode","parentNode","item","scrollIntoView","rendered","nextPageHeights","i","lastBottom","topIndex","bottomIndex","_rendered$item$getBou","bottom","concat","_nextPageHeights","aboveHeight","belowHeight","firstIndex","lastIndex","result","marker","createElement","key","ref","flex","cloneElement","push","slice","itemsIndex","child","_marker","renderedMarker","node","propTypes"],"sources":["C:/Users/michaejo/Documents/GitRepos/player-api/node_modules/grommet/es6/components/InfiniteScroll/InfiniteScroll.js"],"sourcesContent":["function _readOnlyError(r) { throw new TypeError('\"' + r + '\" is read-only'); }\nimport React, { useEffect, useMemo, useRef, useState } from 'react';\nimport { useLayoutEffect } from '../../utils/use-isomorphic-layout-effect';\nimport { findScrollParent, findScrollParents, isNodeAfterScroll, isNodeBeforeScroll } from '../../utils';\nimport { Box } from '../Box';\nimport { InfiniteScrollPropTypes } from './propTypes';\nvar calculateLastPageBound = function calculateLastPageBound(show, step) {\n  return show ? Math.floor((show + step) / step) - 1 : 0;\n};\nvar InfiniteScroll = function InfiniteScroll(_ref) {\n  var children = _ref.children,\n    _ref$items = _ref.items,\n    items = _ref$items === void 0 ? [] : _ref$items,\n    onMore = _ref.onMore,\n    renderMarker = _ref.renderMarker,\n    replace = _ref.replace,\n    show = _ref.show,\n    _ref$step = _ref.step,\n    step = _ref$step === void 0 ? 50 : _ref$step;\n  // item index to be made visible initially\n  var _useState = useState(),\n    scrollShow = _useState[0],\n    setScrollShow = _useState[1];\n\n  // the last page we have items for\n  var lastPage = useMemo(function () {\n    return Math.max(0, Math.ceil(items.length / step) - 1);\n  }, [items.length, step]);\n\n  // the pages we are rendering\n  var _useState2 = useState([0, calculateLastPageBound(show, step)]),\n    renderPageBounds = _useState2[0],\n    setRenderPageBounds = _useState2[1];\n\n  // the heights of the pages, approximated after we render the first page\n  // and then updated for pages that have rendered\n  var _useState3 = useState([]),\n    pageHeights = _useState3[0],\n    setPageHeights = _useState3[1];\n\n  // what we're waiting for onMore to give us\n  var _useState4 = useState(0),\n    pendingLength = _useState4[0],\n    setPendingLength = _useState4[1];\n  var aboveMarkerRef = useRef(); // only when replacing\n  var belowMarkerRef = useRef();\n\n  // scroll and resize handling\n  useEffect(function () {\n    var scrollParents;\n    var evaluate = function evaluate() {\n      if (!scrollParents) return;\n      var scrollParent = scrollParents[0];\n\n      // Determine the scroll position of the scroll container\n      var top;\n      var height;\n      if (scrollParent === document) {\n        top = document.documentElement.scrollTop || document.body.scrollTop;\n        height = window.innerHeight;\n      } else {\n        top = scrollParent.scrollTop;\n        var rect = scrollParent.getBoundingClientRect();\n        height = rect.height;\n      }\n      var offset = height / 4; // so we pre-load when the user scrolls slowly\n\n      // Use the pageHeights to determine what pages we should render based\n      // on the current scroll window.\n      var nextBeginPage = 0;\n      var index = 0;\n      var pagesHeight = pageHeights[index] || 0;\n      while (pageHeights[index + 1] && pagesHeight < top - offset) {\n        index += 1;\n        nextBeginPage += 1;\n        pagesHeight += pageHeights[index];\n      }\n      var nextEndPage = nextBeginPage;\n      while (pageHeights[index] !== undefined && pagesHeight < top + height + offset) {\n        index += 1;\n        nextEndPage += 1;\n        // when we haven't rendered the nextEndPage and we aren't replacing,\n        // we might not have a height for it yet\n        pagesHeight += pageHeights[index] || 0;\n      }\n      if (!replace) {\n        // when not replacing, never shrink bounds\n        nextBeginPage = 0;\n        nextEndPage = Math.max(renderPageBounds[1], nextEndPage);\n      }\n      if (show) {\n        // ensure we try to render any show page\n        var showPage = calculateLastPageBound(show, step);\n        nextBeginPage = Math.min(showPage, nextBeginPage);\n        nextEndPage = Math.max(showPage, nextEndPage);\n      }\n      if (nextBeginPage !== renderPageBounds[0] || nextEndPage !== renderPageBounds[1]) {\n        setRenderPageBounds([nextBeginPage, nextEndPage]);\n      }\n    };\n    var timer;\n    var debounce = function debounce() {\n      clearTimeout(timer);\n      timer = setTimeout(evaluate, 10);\n    };\n\n    // might not be there yet or might have already rendered everything\n    if (belowMarkerRef.current) {\n      scrollParents = findScrollParents(belowMarkerRef.current);\n      scrollParents.forEach(function (sp) {\n        return sp.addEventListener('scroll', debounce);\n      });\n    }\n    window.addEventListener('resize', debounce);\n    evaluate();\n    return function () {\n      if (scrollParents) {\n        scrollParents.forEach(function (sp) {\n          return sp.removeEventListener('scroll', debounce);\n        });\n      }\n      window.removeEventListener('resize', debounce);\n      clearTimeout(timer);\n    };\n  }, [pageHeights, renderPageBounds, replace, show, step]);\n\n  // check if we need to ask for more\n  useEffect(function () {\n    if (onMore && renderPageBounds[1] === lastPage && items.length >= pendingLength && items.length > 0) {\n      // remember we've asked for more, so we don't keep asking if it takes\n      // a while\n      setPendingLength(items.length + 1);\n      onMore();\n    }\n  }, [items.length, lastPage, onMore, pendingLength, renderPageBounds, step]);\n  useEffect(function () {\n    if (items.length === 0 && lastPage === 0 && pendingLength !== 0) {\n      setPageHeights([]);\n      setPendingLength(0);\n      setRenderPageBounds([0, calculateLastPageBound(show, step)]);\n    }\n  }, [lastPage, pendingLength, show, step, items.length]);\n\n  // scroll to any 'show'\n  useLayoutEffect(function () {\n    // ride out any animation delays, 100ms empirically measured\n    var timer = setTimeout(function () {\n      if (show && belowMarkerRef.current && show !== scrollShow) {\n        // calculate show index based on beginPage\n        var showIndex = show - renderPageBounds[0] * step + (renderPageBounds[0] ? 1 : 0);\n        var showNode = belowMarkerRef.current.parentNode.children.item(showIndex);\n        if (showNode) {\n          var scrollParent = findScrollParent(showNode);\n          if (isNodeBeforeScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(true);\n          } else if (isNodeAfterScroll(showNode, scrollParent)) {\n            showNode.scrollIntoView(false);\n          }\n          // clean up after having shown\n          setScrollShow(show);\n        }\n      }\n    }, 100);\n    return function () {\n      return clearTimeout(timer);\n    };\n    // Omitting scrollShow as a dependency due to concern that setScrollShow\n    // is being called within the timer. If left included, re-renders and other\n    // dependency values could change in an unpredictable manner during timer\n    // and potentially result in an infinite loop.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderPageBounds, show, step]);\n\n  // calculate and keep track of page heights\n  useLayoutEffect(function () {\n    // if don't have a belowMarker, we must have rendered everything already\n    if (!belowMarkerRef.current) return;\n\n    // calculate page heights for rendered pages\n    var rendered = belowMarkerRef.current.parentNode.children;\n    // ensure we've rendered the state we have\n    // above? + items in rendered pages + below === rendered DOM elements length\n    if ((aboveMarkerRef.current ? 1 : 0) + (renderPageBounds[1] - renderPageBounds[0] + 1) * step + 1 === rendered.length) {\n      var nextPageHeights;\n\n      // step through each page\n      var i = renderPageBounds[0];\n      var lastBottom;\n      while (i <= renderPageBounds[1]) {\n        var topIndex = (aboveMarkerRef.current ? 1 : 0) + (i - renderPageBounds[0]) * step;\n        var bottomIndex = Math.min(topIndex + step - 1, rendered.length - 1);\n        // we use lastBottom for top to ensure grid layouts work\n        var top = lastBottom !== undefined ? lastBottom : rendered.item(topIndex).getBoundingClientRect().top;\n        var _rendered$item$getBou = rendered.item(bottomIndex).getBoundingClientRect(),\n          bottom = _rendered$item$getBou.bottom;\n        var height = bottom - top;\n        if (bottom && (!pageHeights || pageHeights[i] !== height)) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          nextPageHeights[i] = height;\n        }\n        lastBottom = bottom;\n        i += 1;\n      }\n\n      // estimate page heights for pages we haven't rendered yet\n      while (replace && i <= lastPage) {\n        if (!pageHeights[i] && pageHeights[i] !== pageHeights[0]) {\n          if (!nextPageHeights) nextPageHeights = [].concat(pageHeights || []);\n          // set to first page height\n          var _nextPageHeights = nextPageHeights;\n          nextPageHeights[i] = _nextPageHeights[0];\n        }\n        i += 1;\n      }\n      if (nextPageHeights) setPageHeights(nextPageHeights);\n    }\n  }, [lastPage, pageHeights, renderPageBounds, replace, step]);\n\n  // calculate the height above the first rendered page using the pageHeights\n  var aboveHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = 0;\n    while (i < renderPageBounds[0]) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n    return height;\n  }, [pageHeights, renderPageBounds, replace]);\n\n  // calculate the height below the last rendered page using the pageHeights\n  var belowHeight = useMemo(function () {\n    if (!replace) return 0;\n    var height = 0;\n    var i = renderPageBounds[1] + 1;\n    while (i <= lastPage) {\n      height += pageHeights[i] || 0;\n      i += 1;\n    }\n    return height;\n  }, [lastPage, pageHeights, renderPageBounds, replace]);\n  var firstIndex = renderPageBounds[0] * step;\n  var lastIndex = Math.min((renderPageBounds[1] + 1) * step, items.length) - 1;\n  var result = [];\n  if (aboveHeight) {\n    var marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"above\",\n      ref: aboveMarkerRef,\n      flex: false,\n      height: aboveHeight + \"px\"\n    });\n    if (renderMarker) {\n      // need to give it a key\n      marker = /*#__PURE__*/React.cloneElement(renderMarker(marker), {\n        key: 'above'\n      });\n    }\n    result.push(marker);\n  }\n  items.slice(firstIndex, lastIndex + 1).forEach(function (item, index) {\n    var itemsIndex = firstIndex + index;\n    var child = children(item, itemsIndex);\n    result.push(child);\n  });\n  if (replace || renderPageBounds[1] < lastPage || onMore) {\n    var _marker = /*#__PURE__*/React.createElement(Box, {\n      key: \"below\",\n      ref: !renderMarker && belowMarkerRef || undefined,\n      flex: false,\n      height: (belowHeight || 0) + \"px\"\n    });\n    if (renderMarker) {\n      // need to give it a key\n      var renderedMarker = renderMarker(_marker);\n      _marker = /*#__PURE__*/React.cloneElement(renderedMarker, {\n        key: 'below',\n        // We need to make sure our belowMarkerRef is tied to a component\n        // that has the same parent as the items being rendered. This is so\n        // we can use belowMarkerRef.current.parentNode.children to\n        // get a reference to the items in the DOM for calculating pageHeights.\n        //\n        // Since the caller might have included a ref in what their\n        // renderMarker returns, we have to take care of both refs.\n        // https://github.com/facebook/react/issues/8873#issuecomment-489579878\n        ref: function ref(node) {\n          // Keep your own reference\n          belowMarkerRef.current = node;\n          // Call the original ref, if any\n          var ref = renderedMarker.ref;\n          if (typeof ref === 'function') {\n            ref(node);\n          } else if (ref !== null) {\n            ref.current = node;\n          }\n        }\n      });\n    }\n    result.push(_marker);\n  }\n  return result;\n};\nInfiniteScroll.propTypes = InfiniteScrollPropTypes;\nexport { InfiniteScroll };"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}