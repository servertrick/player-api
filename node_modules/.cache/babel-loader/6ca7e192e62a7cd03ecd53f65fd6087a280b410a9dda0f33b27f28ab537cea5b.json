{"ast":null,"code":"var POST_DECIMAL_DIGITS = 10;\nexport var baseUnit = 24;\nexport var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n  var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians)\n  };\n};\nvar intersection = function intersection(line1Point1, line1Point2, line2Point1, line2Point2) {\n  var x1 = line1Point1.x,\n    y1 = line1Point1.y;\n  var x2 = line1Point2.x,\n    y2 = line1Point2.y;\n  var x3 = line2Point1.x,\n    y3 = line2Point1.y;\n  var x4 = line2Point2.x,\n    y4 = line2Point2.y;\n\n  // Calculate the denominator\n  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n  // Check if lines are parallel (denominator is 0)\n  if (Math.abs(denominator) < 1e-10) {\n    return null; // Lines are parallel or coincident\n  }\n\n  // Calculate the intersection point\n  var t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;\n  var u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;\n\n  // Calculate intersection coordinates\n  var intersectionX = x1 + t * (x2 - x1);\n  var intersectionY = y1 + t * (y2 - y1);\n  return {\n    x: intersectionX,\n    y: intersectionY,\n    // Optional: check if intersection is within line segments\n    withinSegment1: t >= 0 && t <= 1,\n    withinSegment2: u >= 0 && u <= 1\n  };\n};\nexport var lineCommands = function lineCommands(centerX, centerY, radius, angle) {\n  var start = polarToCartesian(centerX, centerY, radius, angle);\n  var d = ['M', centerX.toFixed(POST_DECIMAL_DIGITS), centerY.toFixed(POST_DECIMAL_DIGITS), 'L', start.x.toFixed(POST_DECIMAL_DIGITS), start.y.toFixed(POST_DECIMAL_DIGITS)].join(' ');\n  return d;\n};\nexport var arcCommands = function arcCommands(centerX, centerY, radius, startAngle, endAngle) {\n  // handle that we can't draw a complete circle\n  var normalizedEndAngle = endAngle;\n  /* \n   added endAngle - startAngle >= 360 \n   for SemiCircle the endAngle will never be greater then startAngle \n   since it starts with a startAngle of 270.\n  */\n  if (endAngle > startAngle && endAngle - startAngle >= 360) {\n    normalizedEndAngle = startAngle + 359.99;\n  }\n  var start = polarToCartesian(centerX, centerY, radius, normalizedEndAngle);\n  var end = polarToCartesian(centerX, centerY, radius, startAngle);\n  var arcSweep = normalizedEndAngle - startAngle <= 180 ? '0' : '1';\n  var d = ['M', start.x.toFixed(POST_DECIMAL_DIGITS), start.y.toFixed(POST_DECIMAL_DIGITS), 'A', radius.toFixed(POST_DECIMAL_DIGITS), radius.toFixed(POST_DECIMAL_DIGITS), 0, arcSweep, 0, end.x.toFixed(POST_DECIMAL_DIGITS), end.y.toFixed(POST_DECIMAL_DIGITS)].join(' ');\n  return d;\n};\nexport var calcAngle = function calcAngle(radius, angle, midAngle, gap) {\n  if (gap === 0) {\n    return angle;\n  }\n  var gapAngleRadians = Math.asin(Math.abs(gap) / radius);\n  var gapAngle = gapAngleRadians * 180 / Math.PI;\n  return gap > 0 ? Math.min(angle + gapAngle, midAngle) : Math.max(angle - gapAngle, midAngle);\n};\nvar gapPoints = function gapPoints(centerX, centerY, outerRadius, innerRadius, angle, midAngle, gap) {\n  var outerAngle = calcAngle(outerRadius, angle, midAngle, gap);\n  var outer = polarToCartesian(centerX, centerY, outerRadius, outerAngle);\n  var inner;\n  if (innerRadius > 0) {\n    var innerAngle = calcAngle(innerRadius, angle, midAngle, gap);\n    inner = polarToCartesian(centerX, centerY, innerRadius, innerAngle);\n  } else {\n    inner = polarToCartesian(centerX, centerY, Math.abs(gap), gap < 0 ? angle - 90 : angle + 90);\n  }\n  return {\n    outer: outer,\n    inner: inner\n  };\n};\nexport var wedgeCommands = function wedgeCommands(centerX, centerY, outerRadius, innerRadius, startAngle, endAngle, startGap, endGap, startRound, endRound, startRoundDirection) {\n  if (startRoundDirection === void 0) {\n    startRoundDirection = 0;\n  }\n  // handle that we can't draw a complete circle\n  var normalizedEndAngle = endAngle;\n  /* \n   added endAngle - startAngle >= 360 \n   for SemiCircle the endAngle will never be greater then startAngle \n   since it starts with a startAngle of 270.\n  */\n  if (endAngle > startAngle && endAngle - startAngle >= 359.99) {\n    normalizedEndAngle = startAngle + 359.99;\n  }\n\n  // if we're rounded we need to ajust the start points to\n  // account for a bigger cap radius\n\n  // add a little bit extra to start to allow for larger rounded inset cap\n  // The extra needed can be calculated by the Pythagorean theorem\n  var thickness = outerRadius - innerRadius;\n  var extraGap = startRound ? Math.sqrt(Math.pow(thickness / 2 + startGap / 4, 2) - Math.pow(thickness / 2, 2)) : 0;\n\n  // define the angle at the center of the wedge. We can't let the gap\n  // go past this angle.\n\n  // calculate the angle span between start and end\n  var angleSpan = (endAngle < startAngle ? endAngle + 360 : endAngle) - startAngle;\n  var midAngle = startAngle + angleSpan / 2;\n  var start = gapPoints(centerX, centerY, outerRadius, innerRadius, startAngle, midAngle < startAngle ? midAngle + 360 : midAngle, startGap + extraGap, startRound);\n  var end = gapPoints(centerX, centerY, outerRadius, innerRadius, normalizedEndAngle, midAngle > endAngle ? midAngle - 360 : midAngle, endGap, endRound);\n  var largeAngle = normalizedEndAngle - startAngle > 180;\n  var arcSweep = largeAngle ? '1' : '0';\n  var innerCapRadius = innerRadius;\n  var innerArcSweep = arcSweep;\n  var middle;\n  if (innerRadius <= 0) {\n    // we're doing a pie wedge\n    innerArcSweep = arcSweep === '0' ? '1' : '0';\n    if (largeAngle) {\n      // for a large pie wedge it has an inner corner rather\n      // than a point. We need to round the inner corner\n      innerCapRadius = startGap || endGap || 0;\n    } else {\n      // for a small pie wedge we'll make a point in the center\n      middle = intersection(start.outer, start.inner, end.outer, end.inner);\n    }\n  }\n  var capRadius = (outerRadius - innerRadius) / 2;\n  var startCapRadius = capRadius + (startRoundDirection === 0 ? startGap / 2 : 0);\n  var startPoint = middle || start.inner;\n  var endPoint = middle || end.inner;\n  var startCap = startRound ? ['A', startCapRadius.toFixed(POST_DECIMAL_DIGITS), startCapRadius.toFixed(POST_DECIMAL_DIGITS), 0, 0, startRoundDirection, start.outer.x.toFixed(POST_DECIMAL_DIGITS), start.outer.y.toFixed(POST_DECIMAL_DIGITS)] : ['L', start.outer.x.toFixed(POST_DECIMAL_DIGITS), start.outer.y.toFixed(POST_DECIMAL_DIGITS)];\n  var endCap = endRound ? ['A', capRadius.toFixed(POST_DECIMAL_DIGITS), capRadius.toFixed(POST_DECIMAL_DIGITS), 0, 0, 1, endPoint.x.toFixed(POST_DECIMAL_DIGITS), endPoint.y.toFixed(POST_DECIMAL_DIGITS)] : ['L', endPoint.x.toFixed(POST_DECIMAL_DIGITS), endPoint.y.toFixed(POST_DECIMAL_DIGITS)];\n  var d = ['M', startPoint.x.toFixed(POST_DECIMAL_DIGITS), startPoint.y.toFixed(POST_DECIMAL_DIGITS)].concat(startCap, ['A', outerRadius.toFixed(POST_DECIMAL_DIGITS), outerRadius.toFixed(POST_DECIMAL_DIGITS), 0, arcSweep, 1, end.outer.x.toFixed(POST_DECIMAL_DIGITS), end.outer.y.toFixed(POST_DECIMAL_DIGITS)], endCap);\n  if (innerRadius > 0 || largeAngle) {\n    // for a donut or a large pie wedge, draw the inner arc\n    d.push('A', innerCapRadius.toFixed(POST_DECIMAL_DIGITS), innerCapRadius.toFixed(POST_DECIMAL_DIGITS), 0, innerArcSweep, 0, start.inner.x.toFixed(POST_DECIMAL_DIGITS), start.inner.y.toFixed(POST_DECIMAL_DIGITS), 'Z' // close the path\n    );\n  }\n  return d.join(' ');\n};\n\n/* TranslatedEngAngle will now take the value of the\nstartAngle + anglePer * value and mod by 360. This was added\nto take account the startAngle not being 0. So no matter the\nvalue it will be % 360 to get the correct angle. \n*/\nexport var translateEndAngle = function translateEndAngle(startAngle, anglePer, value) {\n  return Math.max(0, startAngle + anglePer * value) % 360;\n};","map":{"version":3,"names":["POST_DECIMAL_DIGITS","baseUnit","polarToCartesian","centerX","centerY","radius","angleInDegrees","angleInRadians","Math","PI","x","cos","y","sin","intersection","line1Point1","line1Point2","line2Point1","line2Point2","x1","y1","x2","y2","x3","y3","x4","y4","denominator","abs","t","u","intersectionX","intersectionY","withinSegment1","withinSegment2","lineCommands","angle","start","d","toFixed","join","arcCommands","startAngle","endAngle","normalizedEndAngle","end","arcSweep","calcAngle","midAngle","gap","gapAngleRadians","asin","gapAngle","min","max","gapPoints","outerRadius","innerRadius","outerAngle","outer","inner","innerAngle","wedgeCommands","startGap","endGap","startRound","endRound","startRoundDirection","thickness","extraGap","sqrt","pow","angleSpan","largeAngle","innerCapRadius","innerArcSweep","middle","capRadius","startCapRadius","startPoint","endPoint","startCap","endCap","concat","push","translateEndAngle","anglePer","value"],"sources":["C:/Users/michaejo/Documents/GitRepos/player-api/node_modules/grommet/es6/utils/graphics.js"],"sourcesContent":["var POST_DECIMAL_DIGITS = 10;\nexport var baseUnit = 24;\nexport var polarToCartesian = function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n  var angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;\n  return {\n    x: centerX + radius * Math.cos(angleInRadians),\n    y: centerY + radius * Math.sin(angleInRadians)\n  };\n};\nvar intersection = function intersection(line1Point1, line1Point2, line2Point1, line2Point2) {\n  var x1 = line1Point1.x,\n    y1 = line1Point1.y;\n  var x2 = line1Point2.x,\n    y2 = line1Point2.y;\n  var x3 = line2Point1.x,\n    y3 = line2Point1.y;\n  var x4 = line2Point2.x,\n    y4 = line2Point2.y;\n\n  // Calculate the denominator\n  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n\n  // Check if lines are parallel (denominator is 0)\n  if (Math.abs(denominator) < 1e-10) {\n    return null; // Lines are parallel or coincident\n  }\n\n  // Calculate the intersection point\n  var t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denominator;\n  var u = -((x1 - x2) * (y1 - y3) - (y1 - y2) * (x1 - x3)) / denominator;\n\n  // Calculate intersection coordinates\n  var intersectionX = x1 + t * (x2 - x1);\n  var intersectionY = y1 + t * (y2 - y1);\n  return {\n    x: intersectionX,\n    y: intersectionY,\n    // Optional: check if intersection is within line segments\n    withinSegment1: t >= 0 && t <= 1,\n    withinSegment2: u >= 0 && u <= 1\n  };\n};\nexport var lineCommands = function lineCommands(centerX, centerY, radius, angle) {\n  var start = polarToCartesian(centerX, centerY, radius, angle);\n  var d = ['M', centerX.toFixed(POST_DECIMAL_DIGITS), centerY.toFixed(POST_DECIMAL_DIGITS), 'L', start.x.toFixed(POST_DECIMAL_DIGITS), start.y.toFixed(POST_DECIMAL_DIGITS)].join(' ');\n  return d;\n};\nexport var arcCommands = function arcCommands(centerX, centerY, radius, startAngle, endAngle) {\n  // handle that we can't draw a complete circle\n  var normalizedEndAngle = endAngle;\n  /* \n   added endAngle - startAngle >= 360 \n   for SemiCircle the endAngle will never be greater then startAngle \n   since it starts with a startAngle of 270.\n  */\n  if (endAngle > startAngle && endAngle - startAngle >= 360) {\n    normalizedEndAngle = startAngle + 359.99;\n  }\n  var start = polarToCartesian(centerX, centerY, radius, normalizedEndAngle);\n  var end = polarToCartesian(centerX, centerY, radius, startAngle);\n  var arcSweep = normalizedEndAngle - startAngle <= 180 ? '0' : '1';\n  var d = ['M', start.x.toFixed(POST_DECIMAL_DIGITS), start.y.toFixed(POST_DECIMAL_DIGITS), 'A', radius.toFixed(POST_DECIMAL_DIGITS), radius.toFixed(POST_DECIMAL_DIGITS), 0, arcSweep, 0, end.x.toFixed(POST_DECIMAL_DIGITS), end.y.toFixed(POST_DECIMAL_DIGITS)].join(' ');\n  return d;\n};\nexport var calcAngle = function calcAngle(radius, angle, midAngle, gap) {\n  if (gap === 0) {\n    return angle;\n  }\n  var gapAngleRadians = Math.asin(Math.abs(gap) / radius);\n  var gapAngle = gapAngleRadians * 180 / Math.PI;\n  return gap > 0 ? Math.min(angle + gapAngle, midAngle) : Math.max(angle - gapAngle, midAngle);\n};\nvar gapPoints = function gapPoints(centerX, centerY, outerRadius, innerRadius, angle, midAngle, gap) {\n  var outerAngle = calcAngle(outerRadius, angle, midAngle, gap);\n  var outer = polarToCartesian(centerX, centerY, outerRadius, outerAngle);\n  var inner;\n  if (innerRadius > 0) {\n    var innerAngle = calcAngle(innerRadius, angle, midAngle, gap);\n    inner = polarToCartesian(centerX, centerY, innerRadius, innerAngle);\n  } else {\n    inner = polarToCartesian(centerX, centerY, Math.abs(gap), gap < 0 ? angle - 90 : angle + 90);\n  }\n  return {\n    outer: outer,\n    inner: inner\n  };\n};\nexport var wedgeCommands = function wedgeCommands(centerX, centerY, outerRadius, innerRadius, startAngle, endAngle, startGap, endGap, startRound, endRound, startRoundDirection) {\n  if (startRoundDirection === void 0) {\n    startRoundDirection = 0;\n  }\n  // handle that we can't draw a complete circle\n  var normalizedEndAngle = endAngle;\n  /* \n   added endAngle - startAngle >= 360 \n   for SemiCircle the endAngle will never be greater then startAngle \n   since it starts with a startAngle of 270.\n  */\n  if (endAngle > startAngle && endAngle - startAngle >= 359.99) {\n    normalizedEndAngle = startAngle + 359.99;\n  }\n\n  // if we're rounded we need to ajust the start points to\n  // account for a bigger cap radius\n\n  // add a little bit extra to start to allow for larger rounded inset cap\n  // The extra needed can be calculated by the Pythagorean theorem\n  var thickness = outerRadius - innerRadius;\n  var extraGap = startRound ? Math.sqrt(Math.pow(thickness / 2 + startGap / 4, 2) - Math.pow(thickness / 2, 2)) : 0;\n\n  // define the angle at the center of the wedge. We can't let the gap\n  // go past this angle.\n\n  // calculate the angle span between start and end\n  var angleSpan = (endAngle < startAngle ? endAngle + 360 : endAngle) - startAngle;\n  var midAngle = startAngle + angleSpan / 2;\n  var start = gapPoints(centerX, centerY, outerRadius, innerRadius, startAngle, midAngle < startAngle ? midAngle + 360 : midAngle, startGap + extraGap, startRound);\n  var end = gapPoints(centerX, centerY, outerRadius, innerRadius, normalizedEndAngle, midAngle > endAngle ? midAngle - 360 : midAngle, endGap, endRound);\n  var largeAngle = normalizedEndAngle - startAngle > 180;\n  var arcSweep = largeAngle ? '1' : '0';\n  var innerCapRadius = innerRadius;\n  var innerArcSweep = arcSweep;\n  var middle;\n  if (innerRadius <= 0) {\n    // we're doing a pie wedge\n    innerArcSweep = arcSweep === '0' ? '1' : '0';\n    if (largeAngle) {\n      // for a large pie wedge it has an inner corner rather\n      // than a point. We need to round the inner corner\n      innerCapRadius = startGap || endGap || 0;\n    } else {\n      // for a small pie wedge we'll make a point in the center\n      middle = intersection(start.outer, start.inner, end.outer, end.inner);\n    }\n  }\n  var capRadius = (outerRadius - innerRadius) / 2;\n  var startCapRadius = capRadius + (startRoundDirection === 0 ? startGap / 2 : 0);\n  var startPoint = middle || start.inner;\n  var endPoint = middle || end.inner;\n  var startCap = startRound ? ['A', startCapRadius.toFixed(POST_DECIMAL_DIGITS), startCapRadius.toFixed(POST_DECIMAL_DIGITS), 0, 0, startRoundDirection, start.outer.x.toFixed(POST_DECIMAL_DIGITS), start.outer.y.toFixed(POST_DECIMAL_DIGITS)] : ['L', start.outer.x.toFixed(POST_DECIMAL_DIGITS), start.outer.y.toFixed(POST_DECIMAL_DIGITS)];\n  var endCap = endRound ? ['A', capRadius.toFixed(POST_DECIMAL_DIGITS), capRadius.toFixed(POST_DECIMAL_DIGITS), 0, 0, 1, endPoint.x.toFixed(POST_DECIMAL_DIGITS), endPoint.y.toFixed(POST_DECIMAL_DIGITS)] : ['L', endPoint.x.toFixed(POST_DECIMAL_DIGITS), endPoint.y.toFixed(POST_DECIMAL_DIGITS)];\n  var d = ['M', startPoint.x.toFixed(POST_DECIMAL_DIGITS), startPoint.y.toFixed(POST_DECIMAL_DIGITS)].concat(startCap, ['A', outerRadius.toFixed(POST_DECIMAL_DIGITS), outerRadius.toFixed(POST_DECIMAL_DIGITS), 0, arcSweep, 1, end.outer.x.toFixed(POST_DECIMAL_DIGITS), end.outer.y.toFixed(POST_DECIMAL_DIGITS)], endCap);\n  if (innerRadius > 0 || largeAngle) {\n    // for a donut or a large pie wedge, draw the inner arc\n    d.push('A', innerCapRadius.toFixed(POST_DECIMAL_DIGITS), innerCapRadius.toFixed(POST_DECIMAL_DIGITS), 0, innerArcSweep, 0, start.inner.x.toFixed(POST_DECIMAL_DIGITS), start.inner.y.toFixed(POST_DECIMAL_DIGITS), 'Z' // close the path\n    );\n  }\n  return d.join(' ');\n};\n\n/* TranslatedEngAngle will now take the value of the\nstartAngle + anglePer * value and mod by 360. This was added\nto take account the startAngle not being 0. So no matter the\nvalue it will be % 360 to get the correct angle. \n*/\nexport var translateEndAngle = function translateEndAngle(startAngle, anglePer, value) {\n  return Math.max(0, startAngle + anglePer * value) % 360;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}